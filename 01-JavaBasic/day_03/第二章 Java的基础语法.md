# 基础语法

主要介绍标识符、变量、数据类型、运算符。

# 一、标识符

Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符。简单的说，凡是程序员自己命名的部分都可以称为标识符。即给类、变量、方法、包等命名的字符序列，称为==标识符==。

## 1、标识符的命名规则

定义合法标识符规则

（Java语言规范是描述Java语言的官方文档。可以从网站http://docs.oracle.com/javase/specs上阅读或下载）

（1）Java的标识符只能使用26个英文字母大小写，0-9的数字，下划线_，美元符号$

（2）不能使用Java的关键字（包含保留字）和特殊值

（3）数字不能开头      error: 8hello错误的

（4）标识符不能包含空格

（5）Java钟严格区分大小写，大小写敏感

2、标识符的命名规范

标识符的命名**规范**            （起名不规范，两行泪，会被打的）。

在起名字时，为了提高阅读性，要尽量有意义，“**见名知意**”。

（1）见名知意

（2）类名、接口名等：每个单词的首字母都大写，形式：XxxYyyZzz，

例如：HelloWorld，String，System等

（3）变量、方法名等：从第二个单词开始首字母大写，其余字母小写，形式：xxxYyyZzz。

例如：age,name,bookName,main

（4）包名等：每一个单词都小写，单词之间使用点.分割，形式：xxx.yyy.zzz，

例如：java.lang

（5）常量名等：每一个单词都大写，单词之间使用下划线_分割，形式：XXX_YYY_ZZZ，

例如：MAX_VALUE,PI

## 2、关键字、保留字、特殊值

 Java关键字、含义 [https://blog.csdn.net/qq_41569732/article/details/103209422](https://blog.csdn.net/qq_41569732/article/details/103209422)

关键字、保留字和特殊值：全部小写（50+3）
（1）关键字：在Java中被赋予的特定含义的单词。
基本数据类型相关（8个）：byte、short、int、long、float、double、char、boolean 

 8位整数类型（一个字节）、16位整数类型、32位整数类型、64位长整数类型、单精度浮点数类型 四字节、双精度浮点数类型八个字节、 布尔类型

流程控制语句相关（10个）：if、else、switch、case、default、break、for、while、do、continue

判断某个对象是否是某种类型的实例对象运算符：instanceof
定义类：class
创建类的对象：new
包相关：package、import
权限修饰符：public、protected、（缺省）、private
继承类：extends
定义接口：interface
实现接口：implements
当前对象：this
父类引用：super
表示无返回值：void
结束方法：return
定义枚举：enum
其他修饰符：abstract、static、final、native
异常处理：try、catch、finally、throws、throw
多线程同步和安全：synchronized、volatile
和IO序列化相关：transient
和单元测试相关：assert
其他：strictfp（strictfp 关键字可应用于类、接口或方法。如果你想让你的浮点运算更加精确，严格遵守FP-strict的限制,符合IEEE-754规范，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.
）
（2）保留字：在Java中注册但还未使用
goto、const
（3）特殊值：true、false、null

Java 核心技术系列）书名原文： Core Java Volume I—F undamental s (Tenth Edition)

附录A Java关键字

按字母顺序排列

关键字	含义
abstract	抽象类或方法
assert	用来查找内部程序错误
boolean	布尔类型
break	跳出一个switch或循环
byte	8位整数类型（一个字节）
case	switch的一个分支
catch	捕获异常的try块子句
char	Unicode字符类型 （两个字节）
class	定义一个类类型
const	未使用 (保留关键字，没有具体含义)
continue	在循环末尾继续
default	switch 的缺省子句
do	do/while 循环最前面的语句
double	双精度浮点数类型
else	if语句的else子句
enum	枚举类型
extends	定义一个类的父类
final	一个常量，或不能覆盖的一个类或方法
finally	try块中总会执行的部分
float	单精度浮点数类型 四字节
for	一种循环类型
goto	未使用
if	一个条件语句
implements	定义一个类实现的接口
import	导入一个包
instanceof	测试一个对象是否为一个类的实例
int	32位整数类型
interface	一种抽象类型，其中包含可以由类实现的方法
long	64位长整数类型
native	由宿主系统实现的一个方法
new	分配一个新对象或数组
null	一个空引用（需要说明， null从技术上讲是一个直接量， 而不是关键字）
package	包含类 的一个包
private	这个特性只能由该类的方法访问
protected	这个特性只能由该类、其子类以及用一个包中的其他类的方法访问
public	这个特性可以由所有类的方法访问
return	从一个方法返回
short	16位整数类型
static	这个特性是这个类特有的，而属于这个类的对象
strictfp	对浮点数计算使用严格的规则
switch	一个选择语句
super	超类对象或构造函数
synchronized	对线程而言是原子的方法或代码块
this	当前类的一个方法或构造函数的隐含参数
throw	抛出一个异常
throws	一个方法可能抛出的异常
transient	标志非永久的数据
try	捕获异常的代码块
void	指示一个方法不返回如何值
volatile	确保一个字段可以由多个线程访问
while	一种循环

## 3、code

概念

```java
/*
标识符：在Java中对类名、变量名、方法名等这些要素进行命名的字符序列称为标识符。
通俗的理解：凡是程序员自己命名的地方都叫做标识符。
见名知意   单词量
1、标识符的命名规则（必须遵守，否则编译或运行错误）
（1）Java的标识符必须用26个英文字母的大小写、数字0-9，美元符号$，下划线_
（2）Java的标识符不能使用关键字（包含保留字）和特殊值
例如：class,public,static,void等
一共不能用的有50个关键字+3个特殊值
（3）不能使用空格
（4）数字不能开头
（5）Java的标识符严格区分大小写

2、标识符的命名规范（建议遵守，不遵守会被鄙视）
不遵守杀了你 傻逼玩意 谁他妈命名的
（1）见名知意
让别人一看就知道这个类、变量、方法的意义在哪里。

（2）类名、接口名等，要求每一个单词的首字母大写，形式：XxxYyyZzz
例如：HelloWorld，BiaoShiFu
标识符    类名、接口名 要求每一个单词的首字母大小 AaaBbbCcc
（3）变量名、方法名等：要求从第二个单词开始，首字母大写，其余字母小写，
形式：xxxYyyZzz
例如：main()方法，println()方法，print()方法，nextInt()方法
变量名 方法名    驼峰
（4）包名等：要求所有单词都小写，每个单词之间使用.分割
形式：xxx.yyy.zzz
例如：java.lang,java.util,java.io,java.text,java.time等
包名  所有单词小写 . 分割
（5）常量名：要求所有单词都大写，每个单词之间使用_分割
形式：XXX_YYY_ZZZ
例如：PI（圆周率），MAX_VALUE（最大值）

*/
//class Biao Shi Fu{}//错误的，因为包含空格
//class 2Test{}//错误的，数字不能开头
class BiaoShiFu{
}
```





# 二、变量

## 1、变量的概念

变量的作用：变量用来存储数据。

变量的本质：代表内存的一块存储区域，内存的一块存储区域。

变量的值：变量中的值是可以改变的。



声明变量：数据类型 变量名;  `String name;`

变量赋值：变量名 = 变量值;`name = "菜鸡文"`

声明变量和变量的赋值可以同时进行，也可以分开进行。但是在变量被访问之前，必须有值。

例如：数据类型 变量名 = 变量初始值;`String name="菜鸡文"`

## 2、变量的三要素

1、数据类型

2、变量名

3、值

数据类型：决定内存大小，可以存什么值
变量名：如何访问这块存储区域
变量值：里面存储的数据

## 3、变量的使用应该注意什么？

要求：

* 变量必须先声明后使用
* 变量再使用之前必须有初始值
* 变量有作用域

* 在同一个作用域中不能重名



1、先声明后使用

> 如果没有声明，会报“找不到符号”错误

2、在使用之前必须初始化

> 如果没有初始化，会报“未初始化”错误

3、变量有作用域

> 如果超过作用域，也会报“找不到符号”错误

4、在同一个作用域中不能重名



## 4、变量的声明和赋值、使用的语法格式？

1、变量的声明的语法格式：

```java
数据类型  变量名;
例如：
int age;
String name;
double weight;
char gender;
boolean isMarry;
```

2、变量的赋值的语法格式：

```java
变量名 = 值;
例如：
String name = "菜鸡文";//字符串的常量必须用""（双引号）
char gender = '女';//单字符的常量，必须用''（单引号）
double weight = 50.5;//小数类型
boolean marry = true;//布尔类型    真的，假的，成立，不成立
```

3、变量的使用的语法格式：

```java
通过变量名直接引用

例如：
(1)输出变量的值
System.out.print(name);
System.out.print("姓名：" + name);//""中的内容会原样显示
System.out.print("name = " + name);
(2)计算
age = age + 1;
```

## 5、code

变量

```java
/*
环境变量：path
环境变量是给操作系统找xx命令的路径。
path  value

变量：
1、作用：用来存储值（数据）
在Java中，变量本质上，就是代表一块内存区域。
变量中的数据是存储在JVM内存中。
内存区域 什么的内存呢  OS内存  JVM占OS内存一部分的  小块
2、变量有三个要素：
数据类型 变量名  值  String name = "菜鸡文";
（1）数据类型
是用来存储：字符串、小数、整数、单个字符、布尔值、对象....
String  double float byte short int long char boolean
（2）变量名
在程序中，通过变量名来进行访问这块内存及其里面的数据
变量名   访问  内存里面的数据
（3）值
变量中存的具体的值
变量中的值是可以变的
你的值放到你那里  但可以被覆盖了  重新指向什么 还是删除了再指向  垃圾回收 重新指向了
*/
class TestVariable{
    public static void main(String[] args){
        //想要用一个变量，来存储年龄
        //int就是数据类型
        //age就是变量名
        //18就是变量的值
        int age = 18;
        System.out.println(age);

        age = age + 1;

        System.out.println(age);
    }
}
```



变量定义使用

```java
/*
Define：定义，声明
Use：使用
Variable：变量

变量使用的原则：
（1）先声明后使用
包括后面用到的类、方法等，都是遵循先声明后使用
你要声明再使用
声明个女朋友   new一个
光使用不声明？？？。。。
（2）变量必须先初始化（第一次赋值）再访问它的值（打印、计算、比较操作）
必须先初始化
（3）变量的声明，在同一个作用域中，只能声明一次，但是赋值可以很多次
作用域：从变量声明处开始，到它所属的{}结束
我一直给你 一直给你 之前的都没了的
1、如何声明一个变量？
格式：
	数据类型 变量名;

2、如何给变量赋值？
格式：
	变量名 = 变量值;

int double char boolean String
常用的变量的数据类型（刚开始）：
int（整数）
double（小数）
char（单个字符）
String（字符串）
*/
class DefineAndUseVariable{
    public static void main(String[] args){
        //int age;//声明
        //age = 18;//赋值

        //也可以把声明和第一次赋值合并成一句
        int age = 18;
        //	int age = 19;//错误的，第二次赋值不用再加数据类型
        age = 19;//第二次赋值
        System.out.println(age);

        if(true){
            int num = 0;
        }
        //System.out.println(num);//错误的，出了num的作用域

        String name = "菜鸡文";//字符串的常量必须用""（双引号）
        char gender = '女';//单字符的常量，必须用''（单引号）
        double weight = 50.5;//小数类型
        boolean marry = true;//布尔类型    真的，假的，成立，不成立

    }

    public static void test(){
        //System.out.println(age);//错误的，出了age的作用域
    }
}
```



练习 

打印个人信息 

```java
/*
练习1：打印个人信息

（1）数据类型
"xxx" -->字符串
10-->整数，整型
'x'-->字符，单个字符
true-->布尔值，逻辑值，它只有两种情况，true和false
70.5-->小数类型
（2）常量
字符串的常量必须用""（双引号）
单字符的常量，必须用''（单引号）
其他整数、小数、布尔等不需要加符号。

System.out.println(xx);  输出xx之后换行，ln==line
System.out.print(xx);输出xx之后不换行，下面的输出内容就会接着输出
*/
class TestExer1{
    public static void main(String[] args){
        System.out.println("菜鸡文");
        System.out.println(18);
        System.out.println('拿');
        System.out.println(false);
        System.out.println(70);
        System.out.println("--------------------------------");

        System.out.print("姓名：");
        System.out.print("菜鸡文");
        //菜鸡文
        //18
        //拿
        //false
        //70
        //--------------------------------
        //姓名：菜鸡文
        //Process finished with exit code 0
    }
}

```

打印个人信息
个人信息使用变量保存

```java
/*
练习2：打印个人信息
个人信息使用变量保存
*/
class TestExer2{
    public static void main(String[] args){
        String name = "菜鸡文";
        String password = String.valueOf(123456);
        int age = 18;
        char gender = '男';
        double height = 178.0;
        double weight = 70.5;
        boolean marry = false;

        System.out.println(name);
        System.out.println(password);
        System.out.println(age);
        System.out.println(gender);
        System.out.println(height);
        System.out.println(weight);
        System.out.println(marry);
        System.out.println("---------------------");

		/*
		""中的内容，原因显示
		name是变量，在显示的时候，不是显示name单词，而是把name变量中存的值取出来显示，所以这里name不加""
		"姓名：" + name：把姓名:和name变量中的值拼接起来一起显示
		*/
        System.out.println("姓名：" + name);
        System.out.println("年龄：" + age);
        System.out.println("性别：" + gender);
        System.out.println("身高：" + height);
        System.out.println("体重：" + weight);
        System.out.println("是否已婚：" + marry);
    }
}
```

声明一些变量，来保存，一份图书信息：

```java
/*
练习3：
声明一些变量，来保存，一份图书信息：
书名：
作者：
价格：
销量：
库存量：
是否是促销产品：

*/
class TestExer3{
    public static void main(String[] args){
		/*
		String的S是大写的
		*/
        String bookName = "《Java从入门到放弃》";
        String author = "菜鸡文";
        double price = 100.0;
        int sale = 0;
        int amount = 100;
        boolean cu = true;

        System.out.println("书名：" + bookName);
        System.out.println("作者：" + author);
        System.out.println("价格：" + price);
        System.out.println("销量：" + sale);
        System.out.println("库存量：" + amount);
        System.out.println("是否促销：" + cu);
        //书名：《Java从入门到放弃》
        //作者：菜鸡文
        //价格：100.0
        //销量：0
        //库存量：100
        //是否促销：true
    }
}
```





# 三、 数据类型

![image-20200508002732375](imgs/1.png)

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种（primitive type）基本类型，其中有4种整型（byte、short、int、long）、2种浮点类型（float、double）、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。

基本数据类型相关（8个）：byte、short、int、long、float、double、char、boolean 。

 8位整数类型、16位整数类型、32位整数类型、64位长整数类型、32位单精度浮点数类型、64位双精度浮点数类型、 布尔类型。

### 1 、Java数据类型的分类

1、基本数据类型

​	8种：整型系列（byte,short,int,long）、浮点型(float,double)、单字符型（char）、布尔型（boolean）。

byte（1个字节）short（2个字节）int（4个字节，整数的默认类型）long（8个字节）
字节byte：1个字节，-128~127
短整型short：2个字节，-32768~32767。

浮点型：float（4个字节）double（8个字节，小数的默认类型）。

字符型：char（2个字节）。

布尔型：boolean（只有两个值true和false）。

2、引用数据类型

​	类、接口、数组、枚举.....

类（class）/接口（interface）eg:String字符串，数组（[]）。泛型（<>）。



基本数据类型：整型、浮点型、字符型、布尔型

引用数据类型： 类、接口、数组、枚举





### 2、 Java的基本数据类型

1、整型系列

（1）byte：字节类型

占内存：1个字节

存储范围：-128~127

（2）short：短整型类型

占内存：2个字节

存储范围：-32768~32767

（3）int：整型

占内存：4个字节

存储范围：-2的31次方 ~ 2的31次方-1

（4）long：整型

占内存：8个字节

存储范围：-2的63次方 ~ 2的63次方-1

> 注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L



2、浮点型系列（小数）

（1）float：单精度浮点型

占内存：4个字节

精度：科学记数法的小数点后6~7位

> 注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f

（2）double：双精度浮点型

占内存：8个字节

精度：科学记数法的小数点后15~16位



3、单字符类型

char：字符类型

占内存：2个字节

Java中使用的字符集：Unicode编码集

字符的三种表示方式：

（1）'一个字符'

例如：'A'，'0'，'尚'

（2）转义字符

```
\n：换行
\r：回车
\t：Tab键
\\：\
\"：”
\'：
\b：删除键Backspace
```

（3）\u字符的Unicode编码值的十六进制型

例如：\u5c1a代表'尚'



4、布尔类型

boolean：只能存储true或false



5、注意

1. Java的整型常量默认为 int 型，如果想要表示某个整数值是long型时，需要在值后面加L或l ,1与l分不清，一般是使用L来表示的 eg: `long a = 1L;`。java程序中变量常声明为int型，除非不足以表示大数，才使用long。经常使用int呀 整型数据。
2. Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’ eg:`float f=3.14F;`。float可以保证十进制科学计数法小数点后6位有效精度和第7位的部分精度。double可以保证十进制科学计数法小数点后15位有效精度和第16位的部分精度。
3. 字符型的值必须使用单引号，只能而且必须存储单个字符，不能是空单引号。例如：’a’、’\n’、'\u5c1a’。字符型使用Unicode编码（ASCII，特殊字符，中文、日文、韩文......）
4. String是引用数据类型，String的常量值必须使用双引号。单独的双引号也是一个字符串值。eg:`String name="小蚂蚁";`

### 3、了解 进制

计算机中任何的计算和存储都是以二进制方式实现的 0、1

位（bit） — 是计算机中最小的存储单位

字节（byte） — 计算机中基本的存储单元 

1byte = 8bits、1KB = 1024Byte、1MB = 1024KB、1GB = 1024MB、1T = 1024GB



1、进制的分类：

（1）十进制

​	数字组成：0-9

​	进位规则：逢十进一

（2）二进制

​	数字组成：0-1

​	进位规则：逢二进一

（3）八进制

​	数字组成：0-7

​	进位规则：逢八进一

（4）十六进制

​	数字组成：0-9，a~f（或A~F）

​	进位规则：逢十六进一

对于整数，有四种表示方式：

* 二进制：0,1 ，满2进1.以0b或0B开头（字母B大小写均可）。
* 十进制：0-9 ，满10进1.
* 八进制：0-7 ，满8进1.八进制数被冠以0来表示。
* 十六进制：0-9及A-F，满16进1，十六进制数被冠以0X来表示（字母X大小写均可）
  如： 0x3f20（十六进制）   0732 （八进制）

2、请分别用四种类型的进制来表示10，并输出它的结果：（了解）

（1）十进制：正常表示

System.out.println(10);

（2）二进制：0b或0B开头

System.out.println(0B10);

（3）八进制：0开头

System.out.println(010);

（4）十六进制：0x或0X开头

System.out.println(0X10);

```java
class Test01_JinZhi{
    public static void main(String[] args){
        System.out.println(10);//十进制，正常写
        System.out.println(0B10);//二进制，在数字前面加0B或0b
        System.out.println(0b10);//二进制，在数字前面加0B或0b
        System.out.println(010);//八进制，在数字前面加0
        System.out.println(0X10);//十六进制，在数字前面加0X或0x
        System.out.println(0x0f);//15
    }
}
```



3、为什么byte是-128~127？（理解）

1个字节：8位

0000 0001  ~  0111 111 ==> 1~127

1000 0001 ~ 1111 1111 ==> -127 ~ -1

0000 0000 ==>0

1000 0000 ==> -128（特殊规定）

> *解释：*计算机数据的存储（了解）
>
> *计算机数据的存储使用二进制补码形式存储，并且最高位是符号位，1是负数，0是正数。*
>
> *规定：正数的补码与反码、原码一样，称为三码合一；*
>
> ​	    *负数的补码与反码、原码不一样：*
>
> ​	   *负数的原码：把十进制转为二进制，然后最高位设置为1*
>
> ​	   *负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0）*
>
> ​	   *负数的补码：反码+1*
>
> *例如：byte类型（1个字节，8位）*
>
> *25 ==> 原码  0001 1001 ==> 反码  0001 1001 -->补码  0001 1001*
>
> *-25 ==>原码  1001 1001 ==> 反码1110 0110 ==>补码 1110 0111*
>
> 底层是用加法代替减法：-128==》-127-1==》-127+(-1)
>
> ​				       -127- -1 ==> -127 + 1

4、二进制与十进制之间的转换

二进制转成十进制 乘以2的幂数

十进制转成二进制 除以2取余数

![image-20200508012304070](imgs/2.png)



5、二进制 八进制  十六进制互转

二进制转八进制：三位一组，算出这三位对应的十进制值，然后挨个连接上即可

二进制转十六进制：四位一组，算出这四位对应的十进制值，然后挨个连接上即可

![image-20200508012320029](imgs/3.png)



八进制转二进制：把每个位置上的数字当做10进制的数，转成三位的二进制，然后挨个拼接上

十六进制转二进制：把每个位置上的数字当做10进制的数，转成四位的二进制，然后挨个拼接上

![image-20200508012329367](imgs/4.png)

6、十进制与八进制或十进制与十六进制之间的转换，建议通过二进制过渡一下

![image-20200508012344260](imgs/5.png)

7、原码、反码、补码

所有数字在计算机底层都以二进制形式存在。一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。
Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位。

因为机器数是带符号的，因此机器数与一个数的“二进制值”还是有区别的。
计算机以补码的形式保存所有的整数。
正数的原码、反码、补码都相同
负数的补码是其反码加1。
	1.原码
原码即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

+1 原码0000 0001

-1 原码1000 0001

​	2.反码

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

+1 原码 0000 0001  反码 0000 0001

-1 原码 1000 0001  反码 1111 1110

​	3.补码

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

+1 原码 0000 0001  反码 0000 0001 补码 0000 0001

-1 原码 1000 0001  反码 1111 1110 补码 1111 1111

为什么要使用原码、反码、补码表示形式呢？
计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

> 0000 0000：0
>
> 0000 0001 ~ 0111 1111 ： 1~ 127
>
> 1000 0001 ~ 1111 1111 ： -127 ~ -1
>
> 1000 0000：-128
>
>   （-127） - （1） = -128
>
>   （1000 0001 - （0000 0001）= （1000 0000）

![image-20200508012416683](imgs/6.png)

**特殊值：** -1-127的结果应该是-128, 在用补码运算的结果中, **[1000 0000]补 就应该是-128**. 

  但是此时-128，如果用补码到反码，再到原码去计算是不对的，所以**-128是个特殊值，记住它**

8、疑惑解答？

（1）为什么float（4个字节）比long（8个字节）的存储范围大？

（2）为什么double（8个字节）比float（4个字节）精度范围大？

因为float、double底层也是二进制，先把小数转为二进制，然后把二进制表示为科学记数法，然后只保存：

（1）符号位（2）指数位（3）尾数位 网上搜索float型和double型数据的存储方式吧



### 4、 基本数据类型的转换

1、自动类型转换（自动升级）：小容量转为大容量（系统自动完成）

* byte，short，char三者之间不进行运算，若运算都将自动升级为int再做运算

* boolean不与其他任意数据类型转换

* 任何数据类型与String之间使用“+”运算符都将自动“连接”成String类型

  拼接

（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时，

byte->short->int->long->float->double

​            char->

```java
int i = 'A';//char自动升级为int
double d = 10;//int自动升级为double
```



（2）当存储范围小的数据类型与存储范围大的数据类型一起混合运算时，会按照其中最大的类型运算

```java
int i = 1;
byte b = 1;
double d = 1.0;

double sum = i + b + d;//混合运算，升级为double
```

（3）当byte,short,char数据类型进行算术运算时，按照int类型处理

```java
byte b1 = 1;
byte b2 = 2;
byte b3 = (byte)(b1 + b2);//b1 + b2自动升级为int

char c1 = '0';
char c2 = 'A';
System.out.println(c1 + c2);//113 48
```

（4）boolean类型不参与



2、强制类型转换

大容量转小容量，需要使用强制符()，结果可能损失精度或溢出

（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换

double->float->long->int->short->byte

​					   ->char

提示：有风险，可能会损失精度或溢出

```java
double d = 1.2;
int num = (int)d;//损失精度

int i = 200;
byte b = (byte)i;//溢出
```

（2）boolean类型不参与

（3）当某个值想要提升数据类型时，也可以使用强制类型转换

```java
int i = 1;
int j = 2;
double shang = (double)i/j;
```

提示：这个情况的强制类型转换是没有风险的。

byte,short,char之间是互不转换的，包括byte+byte等运算也会变成int

boolean和谁都不转

String类型的数据与任意类型的数据“+”拼接后结果都是String字符串

### 5、 特殊的数据类型转换

1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型

```java
System.out.println("" + 1 + 2);//12
```



2、但是String类型不能通过强制类型()转换，转为其他的类型

```java
String str = "123";
int num = (int)str;//错误的
```

### 6、code

基本数据类型

```java
/*
Java强类型  非常非常重要
Java中的数据类型：
（1）基本数据类型（8种）
（2）引用数据类型
String是引用数据类型

一、基本数据类型
1、整型系列
byte: 字节类型 范围：-128~127
	1个字节  8个位
short:短整型
	2个字节  范围：-32768~32767
int:整型
	4个字节  范围：....
long:长整型
	8个字节
	说明：对于long类型的常量，需要加大写L（建议用大写）或小写l

2、小数类型，浮点型系列
float:
	单精度浮点型，4个字节，
	大概的精度范围是，把小数用科学记数法表示后，小数点后6~7位
	说明：float类型的常量，需要在数字后面加F或f
double：双精度浮点型，8个字节
	大概的精度范围是，把小数用科学记数法表示后，小数点后15~16位

L , F ,

3、字符类型
char：单字符类型，2个字节，可以表示汉字
	在Java中是使用Unicode编码表表示。（兼容ASCII码）
	每一个字符都有一个唯一的Unicode编码值。
	例如：
		数字0，Unicode编码值是48
		数字1，Unicode编码值是49
		...
		字母A，Unicode编码值是65
		字母B，Unicode编码值是66
		...
		字母a，Unicode编码值是97
		字母b，Unicode编码值是98
		...
如何表示char类型的字符常量呢？
（1）'一个字符'，例如：'女','A'
（2）'转义字符'，例如：'\n'（换行）,'\t'（制表位Tab键）,
					'\\'（斜杠）,'\"'（双引号）,'\''（单引号）,
					'\b'（删除键Backspace）,'\r'（回车键）
（3）'斜杠u字符的Unicode编码值的十六进制形式'

4、布尔类型
boolean：只能存两个值之一：true,false
一般boolean的值用于条件判断


计算机表示数据用二进制表示，即0和1
那么一位0或1，我们用bit（位），最小单位
计算机中最基本的单位用的byte字节，
1字节 = 8位
1KB = 1024B
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
...

扩展：
	硬件厂商存储单位用1000进位，不是1024.
	带宽  100Mb,b = bit
    100M  12.5MB/s Mb/s  ？？？
*/
class TestType{
    public static void main(String[] args){
        boolean marry = false;
        if(marry){//marry中的值为true，就表示条件成立
            System.out.println("已婚");
        }else{
            System.out.println("未婚");
        }
        System.out.println("--------------------------");

        byte b = 127;
//        byte b = 129; //不兼容的类型 从int转换到byte可能会有损sun失
        long tel = 18201583096L;

        float f = 1.2F;

        char shuang = '"';//这样可以，表示单个字符
        System.out.println(shuang);
        System.out.println("渐若窥宏大说:\"今天天气真好\"");//这里要输出双引号，需要转义

        char shang = '\u5c1a';
        System.out.println(shang);
    }
}

```

进制

```java
/*
进制：（了解）
Java
十六进制 0x0f 0X0f  表示十进制15
八进制 017  15
二进制 0b1111 0B1111
1、进制的分类
十进制：
	数字范围：0-9
	进位规则：逢十进一
二进制：
	数字范围：0-1
	进位规则：逢二进一
八进制：
	数字范围：0-7
	进位规则：逢八进一
十六进制：
	数字范围：0-9、A-F（或者a-f）
	进位规则：逢十六进一
8对7说我溢出了 16对15我要进位了 2对1说嗯嗯
2 8 16 10

		十进制	二进制	八进制	十六进制
0		0		0		0		0
1		1		1		1		1
2		2		10		2		2
3		3		11		3		3
4		4		100		4		4
5		5		101		5		5
6		6		110		6		6
7		7		111		7		7
8		8		1000	10		8
9		9		1001	11		9
10		10		1010	12		A
11		11		1011	13		B
12		12		1100	14		C
13		13		1101	15		D
14		14		1110	16		E
15		15		1111	17		F
16		16		10000	20		10
。。。。

25		25		11001

本质上，就是生活中的十进制，和计算机世界中的二进制
因为在计算机中二进制数字太长了，在代码中去表示二进制很繁琐，
那么引入了八进制和十六进制，为了快速和简短的表示二进制
为了快速和简短的表示二进制
（1）十进制-->二进制
（2）二进制-->八进制
把二进制从最右边开始，三位一组
（3）二进制-->十六进制
把二进制从最右边开始，四位一组

2、在程序中如何表示某个数字是十进制、二进制、八进制、十六进制
十进制，正常写
二进制，在数字前面加0B或0b
八进制，在数字前面加0
十六进制，在数字前面加0X或0x

3、为什么byte类型的范围是-128~127？
byte是1个字节，1个字节是8位
计算机中是使用“补码”的形式来存储数据的，为了理解/换算“补码”，我们在引入“原码、反码”。
规定：正数的原码、反码、补码三码合一；
	  负数的原码、反码、补码是不同的。
	  因为计算机中把最高位（最左边的二进制位）定为符号位，0表示正数，1表示负数。
正数的原码、反码、补码三码合一
负数的原码、反码、补码是不同的

25：
	原码：0001 1001
	反码：0001 1001
	补码：0001 1001
-25：
	原码：1001 1001
	反码：1110 0110   符号位不变，其余位取反（0变1,1变0）
	补码：1110 0111   在反码上加1
符号位 0 正数  1 负数
负数  反码   补码 - 1



正0: 0000 0000

正数：
	0000 0001   : 1
		|
	0111 1111	: 127
	2^7-1 = 127
负数：补码
	1000 0001	：  补码（1000 0001）-》反码（1000 0000）--》原码（1111 1111） -127
		|
	1111 1111	：	补码（1111 1111）-》反码（1111 1110）--》原码（1000 0001）-1

负0：1000 0000	如果用它表示负0，就浪费了，所以用它来表示其他的数
	-127的二进制的补码：1000 0001
	1的二进制的补码：0000 0001
    1000 0000  -128
    计算机中用符号位来表示正、负
	-127 - 1 = （补码：1000 0001）-（补码：0000 0001） = 补码（1000 0000） = -128
	计算机中用符号位来表示正、负，就是为了底层设计的简化，让符号位也参与计算。

*/
class Test01_JinZhi{
    public static void main(String[] args){
        System.out.println(10);//十进制，正常写
        System.out.println(0B10);//二进制，在数字前面加0B或0b
        System.out.println(0b10);//二进制，在数字前面加0B或0b
        System.out.println(010);//八进制，在数字前面加0
        System.out.println(0X10);//十六进制，在数字前面加0X或0x
        System.out.println(0x0f);//15
    }
}
```

float和double在底层如何存储？

```java
/*
了解：浮点型的float和double在底层如何存储？
计算机中只有二进制？
那么如果存储3.14？
小数涉及：（1）整数部分（2）小数部分（3）这个.（4）正负号
如何底层存储呢

计算机中只有二进制？
那么如何存储3.14呢？

化繁为简：
1、小数-->二进制：
（1）整数部分：除2倒取余
（2）小数部分：乘2取整数部分
小数 二进制
整数部分 除2倒取余
3.14==》11.00100...
截取
2、把这个二进制用科学记数法表示
	1.1 00100.... * n的1次方
用科学计数法表示后，对于二进制的科学计数法，整数部分永远是1，那这样的话，
整数部分就不用存了，小数点也不存了
移动  移位   整数部分永远是1 小数点也不需要存储了

只要存三个内容：（1）正负号（2）挪完后的几次方，指数（3）二进制的小数部分（称为尾数）
float：4个字节，就被分为三个部分，最高位还是符号位，
接下来的8位用来存指数部分，然后剩下的存尾数，额如果存不下的尾数，就舍去了
1 8 23
double：8个字节，就被分为三个部分，最高位还是符号位，
接下来的11位用来存指数部分，然后剩下的存尾数，额如果存不下的尾数，就舍去了
1 11 52
了解：
（1）浮点类型不精确，因为十进制的小数部分转二进制会需要舍去
（2）float类型的4个字节能表示的数字范围比long类型的8个字节还要大
因为浮点型底层存的是指数

*/
public class Test02_FloatDoubleSave{
}
```

基本类型转换

```java
/*
基本数据类型之间的转换：
（1）自动类型转换
①把存储范围小的类型的值赋值给存储范围大的类型的变量，自动可以完成升级
byte->short->int->long->float->double
		char->
②boolean不参与
③byte,short,char如果进行算术运算都会自动升级为int


（2）强制类型转换
①把存储范围大的类型的值，赋值给存储范围小的类型变量时，需要强制类型转换
double->float->long->int->short->byte
						->char
大的给小的   溢出 sun损失精度
强制类型转换是有风险的：可能会溢出或损失精度
②boolean不参与
③当需要把某个存储范围小的变量强制提升为存储范围大的类型时，也可以使用强制类型转换
*/
class Test03_TypeChange{
    public static void main(String[] args){
		/*
		从左边看d1是double类型
		从右边看10是int类型
		int类型的值，赋值给了double类型的变量，那么它会自动升级为double
		*/
        double d1 = 10;
        System.out.println("d1 = " + d1);//d1 = 10.0


		/*
		从左边看i1是int类型
		从右边看10.0是double类型
		double类型的值，赋值给int类型的变量，如果直接赋值会报错：错误: 不兼容的类型: 从double转换到int可能会有损失
		*/
        //int i1 = 10.3;
        int i1 = (int)10.3;
        System.out.println("i1 = " + i1);//i1 = 10

        byte b1 = 127;
        byte b2 = 2;
        //byte b3 = b1 + b2;//报错：不兼容的类型: 从int转换到byte可能会有损失，因为byte+byte就自动升级为int
        byte b3 = (byte)(b1 + b2);
        // 0111 1111  0000 0010    1
        // 1000 0001
        // 反码 1000 0000  原码 1111 1111  -127
        System.out.println("b3 = " + b3);//b3 = -127

        short s1 = 1;
        short s2 = 2;
        //short s3 = s1 + s2;//short+short会自动升级为int
        short s3 = (short)(s1 + s2);
        System.out.println("s3 = " + s3);//s3 = 3

        char c1 = '0';//'0'的编码值是48
        char c2 = '1';//'1'的编码值是49
        //char c3 = c1 + c2;//char+char会自动升级为int
        char c3 = (char)(c1 + c2);
        System.out.println("c3 = " + c3);//'a' 97
        //c3 = a

        boolean flag = true;
        //int num = (int)flag;//不兼容的类型: boolean无法转换为int

        int x = 1;
        int y = 2;
        System.out.println("x / y = " + x/y);//整数/整数，结果还是整数，只保留整数部分
        System.out.println("x / y = " + (double)x/y);//把x的int类型先强制升级为double类型

    }
}
```



```java
/*
数据类型转换的特例：字符串类型
	所有类型与字符串“+”拼接，结果都是字符串
*/
class Test04_TypeChange{
    public static void main(String[] args){
        char c1 = '0';
        char c2 = '1';

		/*
		c1 + c2，按照求和运算，char + char结果是int
		""代表空字符串，
		当int的97与""进行 “+”拼接，结果还是97的字符串
		*/
        System.out.println(c1 + c2 + "");//97
        // '0' + '1' int + ""  48 + 49  97

		/*
		"" + c1，按照“拼接”运算，字符串 + char，结果是字符串，结果是"0"
		"0" + c2，按照“拼接”运算，字符串 + char，结果是字符串，结果是"01"
		*/
        System.out.println("" + c1 + c2 );//01

		/*
		c1 + ""，按照“拼接”运算，char + 字符串 ，结果是字符串，结果是"0"
		"0" + c2，按照“拼接”运算，字符串 + char，结果是字符串，结果是"01"
		*/
        System.out.println(c1 + "" + c2 );//01
    }
}

```







# 四、 运算符

1、按照操作数个数的分类：

（1）一元运算符：操作数只有一个

例如：正号（+），负号（-），自增（++），自减（--），逻辑非（！），按位取反（~）

（2）二元运算符：操作数有两个

例如：加（+），减（-），乘（*），除（/），模（%）

​          大于（>），小于（<），大于等于（>=），小于等于（<=），等于（==），不等于（!=）

​	赋值（=，+=，-=，*=，/=，%=，>>=，<<=。。。）

​	 逻辑与（&），逻辑或（|），逻辑异或（^），短路与（&&），短路或（||）

​	左移（<<），右移（>>），无符号右移（>>>），按位与（&），按位或（|），按位异或（^）

（3）三元运算符：操作数三个

例如： ？ ：



2、Java基本数据类型的运算符：

（1）算术运算符

（2）赋值运算符

（3）比较运算符

（4）逻辑运算符

（5）条件运算符

（6）位运算符（难）

### 1、 算术运算符

加法：+

减法：-

乘法：*

除法：/

> *注意：整数与整数相除，只保留整数部分*

取模：%   取余

> 注意：取模结果的正负号只看被模数

正号：+

负号：-

自增：++

自减：--

> **原则：自增与自减**
>
> **++/--在前的，就先自增/自减，后取值**
>
> **++/--在后的，就先取值，后自增/自减**
>
> 整个表达式的扫描，是从左往右扫描，如果后面的先计算的，那么前面的就暂时先放到“操作数栈”中

代码示例：

```java
int i = 1;
i++;//i=2

int j = 1;
++j;//j=2

int a = 1;
int b = a++;//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的"1"赋值给b,b=1

int m = 1;
int n = ++m;//(1)m先自增,m=2(2)再取m的值“2”放操作数栈(3)再把操作数栈中的"2"赋值给n,n=1

int i = 1;
int j = i++ + ++i * i++;
/*
从左往右加载
(1)先算i++
①取i的值“1”放操作数栈
②i再自增 i=2
（2）再算++i
①i先自增 i=3
②再取i的值“3”放操作数栈
（3）再算i++
①取i的值“3”放操作数栈
②i再自增 i=4
（4）先算乘法
用操作数栈中3 * 3 = 9，并把9压会操作数栈
（5）再算求和
用操作数栈中的 1 + 9 = 10
（6）最后算赋值
j = 10
*/
```



### 2、 赋值运算符

基本赋值运算符：=

扩展赋值运算符：+=，-=，*=，/=，%=...

> 注意：所有的赋值运算符的=左边一定是一个变量
>
> 扩展赋值运算符=右边的计算结果的类型如果比左边的大的话会强制类型转换，所以结果可能有风险。
>
> 扩展赋值运算符的计算：（1）赋值最后算（2）加载数据的顺序是把左边的变量的值先加载，再去与右边的表达式进行计算

```java
int i = 1;
int j = 5;
j *= i++ + j++;//j = j *(i++ + j++);
/*
(1)先加载j的值“5”
(2)在计算i++
①先加载i的值“1”
②再i自增，i=2
(3)再计算j++
①先加载j的值"5"
②再j自增，j=6
(4)算  加法
i + 5 = 6
(5)算乘法
5 * 6 = 30
(6)赋值
j = 30
*/
```



### 3、 比较运算符

大于：>

小于：<

大于等于：>=

小于等于：<=

等于：==		注意区分赋值运算符的=

不等于：!=

> 注意：比较表达式的运算结果一定只有true/false
>
> 比较表达式可以作为（1）条件（2）逻辑运算符的操作数



### 4、 逻辑运算符

> 逻辑运算符的操作数必须是布尔值，结果也是布尔值

逻辑与：&
	运算规则：只有左右两边都为true，结果才为true。
	例如：true & true 结果为true
		   false & true 结果为false
		    true & false 结果为false
		    false & false 结果为false
逻辑或：|
	运算规则：只要左右两边有一个为true，结果就为true。
	例如：true | true 结果为true
		   false | true 结果为true
		   true | false 结果为true
		    false | false 结果为false	
逻辑异或：^
	运算规则：只有左右两边不同，结果才为true。
	例如：true ^ true 结果为false
		    false ^ true 结果为true
		    true ^ false 结果为true
		    false ^ false 结果为false			

逻辑非：!
	运算规则：布尔值取反
	例如：!true 为false
		    !false 为true

短路与：&&
	运算规则：只有左右两边都为true，结果才为true。
	例如：true & true 结果为true
		    true & false 结果为false
		    false & ?  结果就为false
	它和逻辑与不同的是当&&左边为false时，右边就不看了。
	
短路或：||	
	运算规则：只要左右两边有一个为true，结果就为true。
	例如：true | ? 结果为treu
		   false | true 结果为true
		    false | false 结果为false	
	它和逻辑或不同的是当||左边为true时，右边就不看了。

> 开发中一般用短路与和短路或比较多

面试题：&& 和 &的区别？

> &&当左边为false，右边不计算
>
> &不管左边是true还是false，右边都要计算

### 5、 条件运算符

 ? : 

语法格式：

```java
条件表达式 ? 结果表达式1 : 结果表达式2
```

运算规则：

整个表达式的结果：当条件表达式为true时，就取结果表达式1的值，否则就取结果表达式2的值

代码示例：

```java
（1）boolean类型
boolean marry = true;
System.out.println(marry? "已婚" : "未婚");

（2）求最值
int i = 3;
int j = 5;
int max = i>=j ? i : j;
//当i>=j时，max就赋值为i的值，否则就赋值为j的值
```



### 6、 位运算符

二进制位  变化  移 

<<

​	运算规则：左移几位就相当于乘以2的几次方

​	二进制补码左移n位，右边补0

右移：>>

​	运算规则：右移几位就相当于除以2的几次方

无符号右移：>>>

​	运算规则：往右移动后，左边空出来的位直接补0，不看符号位

按位与：&

​	运算规则：

​		1 & 1 结果为1

​		1 & 0 结果为0

​		0 & 1 结果为0

​		0 & 0 结果为0

按位或：|

​	运算规则：

​		1 | 1 结果为1

​		1 | 0 结果为1

​		0 | 1 结果为1

​		0 & 0 结果为0

按位异或：^

​	运算规则：

​		1 ^ 1 结果为0

​		1 ^ 0 结果为1

​		0 ^ 1 结果为1

​		0 ^ 0 结果为0

按位取反：~

​	 运算规则：~0就是1  

​			   ~1就是0

> 如何区分&,|,^是逻辑运算符还是位运算符？
>
> 如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。



### 7、 运算符优先级

![1553858424335](imgs/1553858424335.png)

提示说明：

（1）表达式不要太复杂

（2）先算的使用()



### 8、 运算符操作数类型说明

1、算术运算符

数字和单个字符可以使用算术运算符。

其中+，当用于字符串时，表示拼接。



2、赋值运算符

右边的常量值、表达式的值、变量的值的类型必须与左边的变量一致或兼容（可以实现自动类型转换）或使用强制类型转换可以成功。



3、比较运算符

其他的比较运算符都是只能用于8种基本数据类型。

其中的==和!=可以用于引用数据类型的比较，用于比较对象的地址。（后面讲）

```java
int i = 10;
int j = 10;
System.out.println(i==j);//true

char c1 = '帅';
char c2 = '帅';
System.out.println(c1 == c2);//true
```



4、逻辑运算符

逻辑运算符的操作数必须是boolean值



5、条件运算符

?前面必须是条件，必须是boolean值

结果表达式1和结果表达式2要保持类型一致或兼容



6、位运算符

一般用于整数系列



> 以上运算符都是针对基本数据类型设计的。
>
> 能够用于引用数据类型只有基本的赋值运算符=，和比较运算符中的==和!=。其他运算符都不能用于引用数据类型。
>
> 其中字符串类型还有一个+，表示拼接。